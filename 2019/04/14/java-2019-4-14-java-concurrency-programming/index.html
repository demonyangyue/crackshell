<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>Java并发编程 | crackshell</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="序言过去的数十年，摩尔定律是推动IT行业发展的底层引擎，集成电路芯片上所集成的电路的数目，每隔18个月就翻一倍， 计算能力的提升使得许多想象不到的场景成为了现实。 然而随着硅片线路密度的增加，其复杂性和差错率也呈指数增长，到达纳米级别时，材料的物理、化学性能将发生质的变化，摩尔定律也就要走到尽头。 当一匹马拉不动车的时候，我们不是去换一匹更强壮的马，而是用四匹马来拉。近年来，我们不再拼命提升单个C">
<meta name="keywords" content="Java,Concurrent Programming">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程">
<meta property="og:url" content="http://demonyangyue.github.io/2019/04/14/java-2019-4-14-java-concurrency-programming/index.html">
<meta property="og:site_name" content="crackshell">
<meta property="og:description" content="序言过去的数十年，摩尔定律是推动IT行业发展的底层引擎，集成电路芯片上所集成的电路的数目，每隔18个月就翻一倍， 计算能力的提升使得许多想象不到的场景成为了现实。 然而随着硅片线路密度的增加，其复杂性和差错率也呈指数增长，到达纳米级别时，材料的物理、化学性能将发生质的变化，摩尔定律也就要走到尽头。 当一匹马拉不动车的时候，我们不是去换一匹更强壮的马，而是用四匹马来拉。近年来，我们不再拼命提升单个C">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://demonyangyue.github.io/images/visibility.png">
<meta property="og:image" content="http://demonyangyue.github.io/images/order.jpg">
<meta property="og:image" content="http://demonyangyue.github.io/images/lock-strip.jpg">
<meta property="og:updated_time" content="2020-11-22T16:22:07.562Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java并发编程">
<meta name="twitter:description" content="序言过去的数十年，摩尔定律是推动IT行业发展的底层引擎，集成电路芯片上所集成的电路的数目，每隔18个月就翻一倍， 计算能力的提升使得许多想象不到的场景成为了现实。 然而随着硅片线路密度的增加，其复杂性和差错率也呈指数增长，到达纳米级别时，材料的物理、化学性能将发生质的变化，摩尔定律也就要走到尽头。 当一匹马拉不动车的时候，我们不是去换一匹更强壮的马，而是用四匹马来拉。近年来，我们不再拼命提升单个C">
<meta name="twitter:image" content="http://demonyangyue.github.io/images/visibility.png">
  
    <link rel="alternate" href="/atom.xml" title="crackshell" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">crackshell</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Hack on heaven&#39;s door</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://demonyangyue.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java-2019-4-14-java-concurrency-programming" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/14/java-2019-4-14-java-concurrency-programming/" class="article-date">
  <time datetime="2019-04-13T16:00:00.000Z" itemprop="datePublished">2019-04-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Programming/">Programming</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java并发编程
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>过去的数十年，摩尔定律是推动IT行业发展的底层引擎，<code>集成电路芯片上所集成的电路的数目，每隔18个月就翻一倍</code>， 计算能力的提升使得许多想象不到的场景成为了现实。</p>
<p>然而随着硅片线路密度的增加，其复杂性和差错率也呈指数增长，到达纳米级别时，材料的物理、化学性能将发生质的变化，摩尔定律也就要走到尽头。</p>
<p>当一匹马拉不动车的时候，我们不是去换一匹更强壮的马，而是用四匹马来拉。近年来，我们不再拼命提升单个CPU的计算能力，而是靠多个CPU或者多台计算机(分布式集群)同时计算，来获得更强大的计算能力。为了驱动多CPU同时计算， 我们需要具有并发能力的程序。</p>
<a id="more"></a>
<p>但是世界上没有免费的午餐，要获得更强的计算能力，也要付出相应的代价，并发程序要比单线程程序难上一个数量级，主要体现在:</p>
<ul>
<li><p>难以理解</p>
<p>多核计算机可以很好地并发执行任务，和计算机模型不同，人类的大脑，其思维方式，天然是串行的。<code>左手画圆，右手画方</code>，在人类大脑的控制下是做不到的，只能依靠肌肉记忆实现。</p>
</li>
<li><p>难以开发</p>
<p>操作系统底层的并发模型，与语言框架提供的并发语义之间，并不是无缝连接的，开发者一不小心，可能会掉入那些潜在的深渊。</p>
</li>
<li><p>难以测试</p>
<p>由于并发任务本质的复杂性，并发程序也是难以测试的。你无法知道线程之间会以怎样的顺序执行，会在哪个资源上面产生竞争，之前正常运行了很久的并发程序，有可能在某个深夜莫名崩溃。</p>
</li>
</ul>
<p>还记得第一次遇到并发Bug的无助感吗？</p>
<p>本文主要讨论如何在Java项目中编写<strong>正确</strong>的并发程序。</p>
<h2 id="并发的困境"><a href="#并发的困境" class="headerlink" title="并发的困境"></a>并发的困境</h2><p>并发程序需要面对两类问题: 线程安全性和线程活跃性，它们互为硬币的两面。</p>
<p>线程安全性代表了并发程序的正确性，指的是在多线程环境下，应用程序始终能够表现出正确的行为。</p>
<p>线程活跃性代表了并发程序的执行效率，指的是引入多线程后，比原来的单线程程序降低了多少执行时间。</p>
<p>在并发程序中，遇到资源竞争时，为了保证线程安全性，通常会引入某种同步手段，保证任意时刻只有一个线程访问资源。但是这种情况下，其它线程会因为等待资源而被挂起，延长总体执行时间，可能会引起线程活跃性问题。我们引入并发程序的目的是为了提高程序的执行性能，活跃性问题让我们与目标背道而驰。</p>
<h2 id="灾难从何而来"><a href="#灾难从何而来" class="headerlink" title="灾难从何而来"></a>灾难从何而来</h2><h3 id="线程安全性问题的根源"><a href="#线程安全性问题的根源" class="headerlink" title="线程安全性问题的根源"></a>线程安全性问题的根源</h3><p>所有的线程安全性问题，都可以归结于同一个原因: 共享的可变状态。</p>
<p>首先来看状态的共享，在Java中，如果类的某个域被声明为public，或者通过public方法返回了某个private域的引用，那么这个域就可以被其它对象访问到，可以认为基于该类创建的对象，共享了其状态。</p>
<p>一旦状态被共享，宿主对象就失去了状态的完全控制权，你无法预知其它对象会对共享状态做怎样的误操作。</p>
<p>接下来看状态的可变。<code>变量</code>是Java世界中最常见的公民，绝大多数的对象都是可变的。在并发代码中，状态的可变性会面临3个问题:</p>
<ul>
<li><p>原子性</p>
<p>修改变量状态的单次操作，未必是原子的。在线程A修改变量的过程中，线程B可能看到的是状态修改到一半的变量。比如以下的请求统计程序，就是非线程安全的，因为自增(++)操作是非原子的。</p>
<p>自增操作包含了三步子操作: 从内存中读出当前值，在线程本地缓存将当前值加1，将新值写回本地缓存。在线程A执行中执行任何一步子操作时，都可能被挂起转而执行线程B，导致线程B看到的是修改之前的旧值。</p>
</li>
</ul>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a unique value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可见性</p>
<p>在线程A中修改的变量，线程B中未必可以立即看到，这是由计算机的内存模型决定的:</p>
<p><img src="/images/visibility.png" alt></p>
<p>线程A中对变量的修改，首先存储到线程的本地缓存(Cache)中，只有等刷新到主存(Main Memory)之后，线程B才可以看到变量的新值。</p>
</li>
<li><p>有序性</p>
<p>现代微处理器会通过指令乱序执行(out-of-order execution)来提升执行效率，除了处理器，Java自身的JIT编辑器也会对指令做重排序，最终生成的机器指令可能与字节码顺序并不一致。</p>
<p>在并发程序中，指令重排序可能会导致预期之外的执行结果，比如以下的程序，在多线程执行时，线程1中的语句可能会被乱序执行，<code>flg=true</code>可能会先于<code>a=1</code>被执行，则线程2可能会出乎意料地打印出 <code>a = 2</code>。</p>
<p><img src="/images/order.jpg" alt></p>
</li>
</ul>
<h3 id="线程活跃性问题的根源"><a href="#线程活跃性问题的根源" class="headerlink" title="线程活跃性问题的根源"></a>线程活跃性问题的根源</h3><p>遇到活跃性问题的并发程序，被称为(Poor Concurrency)应用程序，活跃性问题可能有很多原因引起:</p>
<ul>
<li>线程开销。线程虽然比进程轻量，但是线程的管理仍然需要消耗一定的系统资源。比如线程上下文切换，需要5000~10000个时钟周期，大约是几微秒，如果线程上下文切换过于频繁，就会对活跃性造成影响。</li>
<li>阻塞。当线程被不恰当地置为阻塞状态时，后续的指令得不到执行，于是就会出现活跃性问题。</li>
<li>死锁。死锁是最常见的活跃性风险。当两个线程互相等待对方持有的资源时，就会发生死锁。不恰当的加锁解锁顺序，以及错误的资源管理策略，都有可能导致死锁。死锁往往出现在最糟糕的时候 —— 高负载的情形。</li>
<li>活锁。当线程不断地重试某个失败的操作时，就会发生活锁。此时线程虽然不会被阻塞，但也不能继续执行。</li>
</ul>
<h2 id="走出困境"><a href="#走出困境" class="headerlink" title="走出困境"></a>走出困境</h2><p>既然并发程序有这么多问题，那么我们该如何避免或者解决这些问题呢?</p>
<h3 id="解决线程安全性问题"><a href="#解决线程安全性问题" class="headerlink" title="解决线程安全性问题"></a>解决线程安全性问题</h3><p>线程安全性是并发代码最重要也是最基本的要求，我们不应容忍大部分时候可以正确运行，但是在偶然情况下会出错的并发程序。</p>
<p>上文已经提到，共享可变状态是造成线程不安全的唯一原因，那么为了解决线程安全性问题，可以先从避免共享状态或者避免可变状态入手。</p>
<h4 id="避免共享状态"><a href="#避免共享状态" class="headerlink" title="避免共享状态"></a>避免共享状态</h4><p>如何避免共享状态呢?理想的情况是构造无状态的程序，没有状态自然也就不会共享。一个典型的例子就是Servlet程序，各Servlet自身并不持有状态，彼此隔离，互不相扰。</p>
<p>如果持有状态不可避免，则可以使用线程封闭技术，将状态’隐藏起来’，不让别的线程访问到。常见的有栈封闭和ThreadLocal类两种形式。</p>
<p>栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量访问对象，这些局部变量被封闭在执行线程的栈内部，其它线程无法访问到它们。举个栗子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTheArk</span><span class="params">(Collection&lt;Animal&gt; candidates)</span> </span>&#123;</span><br><span class="line">    SortedSet&lt;Animal&gt; animals;</span><br><span class="line">    <span class="keyword">int</span> numPairs = <span class="number">0</span>;</span><br><span class="line">    Animal candidate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// animals confined to method, don't let them escape!</span></span><br><span class="line">    animals = <span class="keyword">new</span> TreeSet&lt;Animal&gt;(<span class="keyword">new</span> SpeciesGenderComparator());</span><br><span class="line">    animals.addAll(candidates);</span><br><span class="line">    <span class="keyword">for</span> (Animal a : animals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate == <span class="keyword">null</span> || !candidate.isPotentialMate(a))</span><br><span class="line">            candidate = a;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ark.load(<span class="keyword">new</span> AnimalPair(candidate, a));</span><br><span class="line">            ++numPairs;</span><br><span class="line">            candidate = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numPairs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>animals</code>和<code>candidate</code>是函数的局部变量，被封闭在栈帧内部，不会逸出，被其它线程访问到，所以该方法是线程安全的。</p>
<p>ThreadLocal类能使线程中的某个值与保存值的对象关联起来，在单个线程内部共享这个变量，而其它线程无法访问。一个典型的示例是数据库连接会话，将连接会话存储为ThreadLocal对象，线程内部共享同一个连接会话，不同线程之间的连接会话互不影响。举个栗子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder</span><br><span class="line">           = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  <span class="keyword">return</span> DriverManager.getConnection(DB_URL);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> connectionHolder.get();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="避免可变状态"><a href="#避免可变状态" class="headerlink" title="避免可变状态"></a>避免可变状态</h4><p>线程安全性是不可变对象的固有属性，对于不可变对象，所有线程看到状态必然是一致的。</p>
<p>纯函数式编程语言中，没有变量，只有常量，状态不能被持有，只能通过函数参数来传递，所以是天然的线程安全。</p>
<p>Java没有这样得天独厚的基因，不可变类型需要自己实现，具体的实现方式可以参考《Effective Java》 “最小化可变性”这一节，概括来讲需要遵循以下5条原则:</p>
<ol>
<li>不要提供修改对象状态的方法</li>
<li>确保这个类不能被继承</li>
<li>把所有属性设置为final</li>
<li>把所有的属性设置为private</li>
<li>禁止访问类内部的可变域</li>
</ol>
<p><a href="https://github.com/google/guava" target="_blank" rel="noopener">Guava库</a>也提供了一组不可变类，比如<code>ImmutabelList</code>、<code>ImmutableSet</code> 这些，我们应该在代码中尽可能地使用它们。</p>
<h4 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h4><p>如果共享和可变都无法避免，那么只有使用下策 —— 同步机制，来保证线程安全性。</p>
<p>在Java代码中，通常使用<code>synchronized</code>关键字，对类或者对象加锁，来实现同步。被<code>synchronized</code>修饰的代码块及方法，在同一时间，只能被单个线程访问。<code>synchronized</code>关键字以’退化到单线程’的方法，解决并发安全性的问题。</p>
<p>举个栗子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">     <span class="comment">//同步方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同步代码块</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncBlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的示例代码，编译后的字节码为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncMethod</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello World</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syncBlock</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: ldc           #5                  // class com/hollis/SynchronizedTest</span><br><span class="line">         <span class="number">2</span>: dup</span><br><span class="line">         <span class="number">3</span>: astore_1</span><br><span class="line">         <span class="number">4</span>: monitorenter</span><br><span class="line">         5: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         8: ldc           #3                  // String Hello World</span><br><span class="line">        10: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        <span class="number">13</span>: aload_1</span><br><span class="line">        <span class="number">14</span>: monitorexit</span><br><span class="line">        <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">        <span class="number">18</span>: astore_2</span><br><span class="line">        <span class="number">19</span>: aload_1</span><br><span class="line">        <span class="number">20</span>: monitorexit</span><br><span class="line">        <span class="number">21</span>: aload_2</span><br><span class="line">        <span class="number">22</span>: athrow</span><br><span class="line">        <span class="number">23</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>对于同步方法，JVM使用<code>ACC_SYNCHRONIZED</code>标记符，对于同步代码块，JVM采用<code>monitorenter</code>、<code>monitorexit</code>指令。这两种方式殊途同归，都是通过获取和对象关联的监视器锁(monitor), 来实现同步的。</p>
<p>synchronized 关键字，同时解决了原子性、可见性、有序性问题:</p>
<ul>
<li>原子性。通过监视器锁，可以保证<code>synchronized</code>修饰的代码在同一时间，只能被一个线程访问，在锁未释放之前其它线程无法进入该方法或代码块，保证了操作的原子性。</li>
<li>可见性。按照Java内存模型（Java Memory Model ,JMM）的规范，对一个变量解锁之前，必须先把此变量同步回主存中，这样解锁后，后续线程就可以访问到被修改后的值。所以被synchronized锁住的对象，其值具有可见性。</li>
<li>有序性。synchronized 关键字并不禁止指令重排，但是由于程序是以单线程的方式执行的，所以执行的结果是确定的，不会受指令重排的干扰，有序性不再是个问题。</li>
</ul>
<p>需要注意的是，当我们使用synchronized 关键字，管理某个状态时，必须对访问这个对象的所有操作，都加上synchronized 关键字， 否则仍然会有并发安全性问题。</p>
<h3 id="解决线程活跃性问题"><a href="#解决线程活跃性问题" class="headerlink" title="解决线程活跃性问题"></a>解决线程活跃性问题</h3><p>要避免线程活跃性问题，需要我们对并发机制有深刻了解，并养成良好的并发编程习惯。常见的解决并发活跃性问题的手段有:</p>
<ul>
<li>避免使用锁。这是釜底抽薪、从源头解决的问题的办法。没有买卖就没有伤害，没有锁就不会陷入单线程执行模式，就不会有线程活跃性问题。可以使用上文提到的避免可变状态、避免共享状态等手段，来规避对锁的使用。</li>
<li>降低锁的粒度。如果加锁不可避免，那么可以尝试降低锁的粒度，只在确实需要使用锁的地方才使用它。比如可以在一个方法内部，只对其中的某几行代码，引入<code>synchornized</code>对代码块进行同步。</li>
<li>加上超时限制。并发程序可能会以出乎意料的方式，陷入长时间的锁等待，甚至是死锁。作为止血方案，可以使用显示锁(Lock类)，并指定超时时限(Timeout), 在超过该时间之后就返回一个失败信息，避免永久等待。</li>
</ul>
<p>当出现线程活跃性问题时，我们可以借助一些工具进行诊断:</p>
<ul>
<li>Jstack。通过<code>jstack</code>命令，获取线程执行信息，找出其中的线程阻塞和死锁问题。</li>
<li>Heap dump。通过<code>jmap</code>命令dump出当前的jvm 堆栈信息，然后使用内存分析工具识别线程阻塞和死锁。</li>
<li><a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">Arthas</a>。作为阿里开源的Java诊断利器，arthas也提供了线程分析诊断功能, 可以通过<code>arthas</code>的<code>thread</code>命令，查找出当前阻塞的线程。</li>
</ul>
<h3 id="Java并发类库"><a href="#Java并发类库" class="headerlink" title="Java并发类库"></a>Java并发类库</h3><p><code>java.util.concurrent</code> 包提供了一系列的并发工具类，让我们能够站在巨人的肩膀上，更加高效地实现并发程序。需要注意的是，我们一定要在正确地理解了当前所要处理的并发问题，以及工具类的机制原理之后，再去选择相应的并发工具类。如果只是一知半解就去盲目使用，很可能会给自己挖坑。</p>
<p>下面选择一些比较常用的并发工具类并简要介绍。</p>
<h4 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h4><p>在并发程序中，线程的创建和管理是一个重要的命题。实际的生产代码中，不能为每一个任务就创建一个线程，也就是不能出现<code>new Thread(runnable).start()</code>这样的代码，因为线程是昂贵的系统资源，不能无节制地创建，需要使用线程池对线程进行管理。</p>
<p>Excutor类支持了线程资源的管理和多线程任务的调度。可以使用Executors中的静态方法之一来创建一种线程池(newFixedThreadPool、newCachedThreadPool、newSingleThreadPool、newScheduledThreadPool等)，可以使用Runalbe、Callable来提交并发任务，Excutor类会自己负责任务的调度，解耦了任务的提交和执行。</p>
<p>举个栗子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"task interrupted"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Integer&gt; future = executor.submit(task);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"future done? "</span> + future.isDone());</span><br><span class="line"></span><br><span class="line">Integer result = future.get();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"future done? "</span> + future.isDone());</span><br><span class="line">System.out.print(<span class="string">"result: "</span> + result);</span><br></pre></td></tr></table></figure>
<p>在使用Excutor时，如果线程池的任务之间存在依赖，线程池中的某些任务需要无限期地等待一些其它任务提供的资源；或者某些任务运行耗时较长，其它任务得不到运行资源，则会出现线程饥饿，引发活跃性问题，需要避免。</p>
<h4 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h4><p>从Java5.0开始，提供了一组原子类变量(例如<code>AtomicInteger</code>,<code>AtomicLong</code>,<code>AtomicBoolean</code>,<code>AtomicReference</code>等)， 来支持对单个变量的原子性操作。</p>
<p>内置的监视器锁，是一种悲观锁，任何时候只有一个线程可以持有该锁，其它想获取该锁的线程必须阻塞等待。而<code>Atomic</code> 类提供了一种乐观机制，任何线程都可以尝试获取资源并更新，如果在更新的过程中存在来自其它线程的干扰，那么这个操作将失败并可以重试。</p>
<p><code>Atomic</code>的实现依赖于处理器提供的CAS(Compare and Swap)指令。CAS是一个原子性操作，包含三个操作数：需要读写的内存位置V、旧值A和拟写入的新值B。线程读取V的值，如果等于A，则将V的值更新为B，返回成功，否则返回失败。</p>
<p>举个栗子，以下的代码就是线程安全的，而不需要显示地同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a unique value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对于内置的监视器锁，<code>Atomic</code>更加地轻量和高效，不存在死锁和活跃性问题。其主要劣势在于，需要调用者来处理竞争问题，决定在CAS操作失败时是重试、回退还是放弃。</p>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>Lock类提供了一种可轮询的、定时的以及可中断的锁获取操作，当内置锁无法满足使用场景的要求时，可以考虑使用显式的Lock。举一个带有时间限制的Lock示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimedLocking</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">trySendOnSharedLine</span><span class="params">(String message,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> nanosToLock = unit.toNanos(timeout)</span><br><span class="line">                - estimatedNanosToSend(message);</span><br><span class="line">        <span class="keyword">if</span> (!lock.tryLock(nanosToLock, NANOSECONDS))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sendOnSharedLine(message);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>上文中提到，为了解决线程活跃性问题，提高并发执行效率，一种可行的方案是降低锁的粒度。<code>ConcurrentHashMap</code>可以看作这种思路的优秀实践，内部使用了分段锁(Lock Striping)的方式来降低锁的粒度，使用一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶，由 N%16 个锁来维护。其原理如下图所示:</p>
<p><img src="/images/lock-strip.jpg" alt></p>
<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p><code>CountDownLatch</code>的作用相当于一扇门，在到达结束状态之前，这扇门一直是关闭的，没有任何线程可以通过，当到达结束状态时，这扇门会打开，并允许所有的线程通过。<code>CountDownLatch</code> 可以用来保证某些活动直到其它活动都完成之后才继续执行。举个栗子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHarness</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">timeTasks</span><span class="params">(<span class="keyword">int</span> nThreads, <span class="keyword">final</span> Runnable task)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch startGate = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch endGate = <span class="keyword">new</span> CountDownLatch(nThreads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        startGate.await();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            task.run();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            endGate.countDown();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line">        startGate.countDown();</span><br><span class="line">        endGate.await();</span><br><span class="line">        <span class="keyword">long</span> end = System.nanoTime();</span><br><span class="line">        <span class="keyword">return</span> end - start;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上测试并发程序执行时间的示例中，通过插入’启动门’(startGate对象)，避免了将线程启动时间统计在内，通过插入’结束门’(endGate对象)，保证了所有线程执行完成之后，再获取结束时间。</p>
<h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>信号量<code>Semaphore</code>，用来控制同时访问某个特定资源的操作数量。<code>Semaphore</code>中管理着一组虚拟许可，如果没有许可，则<code>acquire</code>操作将阻塞直到有许可。可以把锁看做一种特殊的二元信号量。举一个代码示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedHashSet</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;T&gt; set;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore sem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoundedHashSet</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;T&gt;());</span><br><span class="line">        sem = <span class="keyword">new</span> Semaphore(bound);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(T o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sem.acquire();</span><br><span class="line">        <span class="keyword">boolean</span> wasAdded = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wasAdded = set.add(o);</span><br><span class="line">            <span class="keyword">return</span> wasAdded;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!wasAdded)</span><br><span class="line">                sem.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> wasRemoved = set.remove(o);</span><br><span class="line">        <span class="keyword">if</span> (wasRemoved)</span><br><span class="line">            sem.release();</span><br><span class="line">        <span class="keyword">return</span> wasRemoved;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过<code>Semaphore</code>实现了一个有界集合。</p>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>基于测试的目的，并发程序测试可以分为两类:安全性测试和活跃性测试。</p>
<p>编写正确的并发测试程序，比编写正确的并发程序本身更加困难，它要求测试用例的编写者对被测代码运行机制有深切的洞察，否则很难写出有效的测试程序。</p>
<p>由于并发问题常常隐藏得比较深，并发测试程序可能需要多次、长时间地执行，才能暴露目标程序中的问题，压测是发现并发问题的有效方案。</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>要写出完全线程安全的Java代码，现实中困难重重，你调用的第三方类库常常是一个黑盒，既没有文档说明其线程安全性保证，又无法看到其内部具体实现，于是用户很难知道在并发环境中使用该类时，是否要添加额外的同步机制。</p>
<p>我们可以通过文档缓解这个问题。在自己发布的类库中，如果使用时需要额外的同步机制，那么就显式地在文档中标注出来。给用户一个解决并发问题的机会，否则就是在制造问题坑人。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>并发程序，需要在设计之初，就要尽可能保证其正确性。草率设计完之后再去优化的代价太高了，潘多拉的魔盒一旦打开，厄运的齿轮就会开始转动。</p>
<p>如果用户在使用一门语言解决并发问题时，必须要理解很多底层原理和细节，才能开始编码，战战兢兢写完代码之后，发现制造的问题比解决的问题还要多，那么这门语言针对并发场景的解决方案就算不得成功。</p>
<p>愿岁月对Java工程师温柔以待。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://demonyangyue.github.io/2019/04/14/java-2019-4-14-java-concurrency-programming/" data-id="ckhtbzbm7000qrhlzf1lhel22" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Concurrent-Programming/">Concurrent Programming</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/06/flink-2020-04-06-flink-1/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Flink原理、架构与实现Part1 - 大数据历史
        
      </div>
    </a>
  
  
    <a href="/2019/01/28/miscellaneous-2019-01-28-restart/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">重新出发</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Miscellaneous/">Miscellaneous</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Programming/">Programming</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Akka/">Akka</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Big-Data/">Big Data</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Cloud-Computing/">Cloud Computing</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Concurrent-Programming/">Concurrent Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flink/">Flink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Guava/">Guava</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Interperter/">Interperter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mesos/">Mesos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Meta-Programming/">Meta Programming</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rails/">Rails</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ruby/">Ruby</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scala/">Scala</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scheme/">Scheme</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spark/">Spark</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Streaming-System/">Streaming System</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jQuery/">jQuery</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂项/">杂项</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Akka/" style="font-size: 16.67px;">Akka</a> <a href="/tags/Big-Data/" style="font-size: 13.33px;">Big Data</a> <a href="/tags/Cloud-Computing/" style="font-size: 20px;">Cloud Computing</a> <a href="/tags/Concurrent-Programming/" style="font-size: 10px;">Concurrent Programming</a> <a href="/tags/Flink/" style="font-size: 11.67px;">Flink</a> <a href="/tags/Guava/" style="font-size: 10px;">Guava</a> <a href="/tags/Interperter/" style="font-size: 10px;">Interperter</a> <a href="/tags/Java/" style="font-size: 11.67px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Mesos/" style="font-size: 10px;">Mesos</a> <a href="/tags/Meta-Programming/" style="font-size: 13.33px;">Meta Programming</a> <a href="/tags/Rails/" style="font-size: 16.67px;">Rails</a> <a href="/tags/Ruby/" style="font-size: 13.33px;">Ruby</a> <a href="/tags/Scala/" style="font-size: 18.33px;">Scala</a> <a href="/tags/Scheme/" style="font-size: 10px;">Scheme</a> <a href="/tags/Spark/" style="font-size: 10px;">Spark</a> <a href="/tags/Streaming-System/" style="font-size: 11.67px;">Streaming System</a> <a href="/tags/Web/" style="font-size: 16.67px;">Web</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/杂项/" style="font-size: 10px;">杂项</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">May 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/06/">June 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/23/bigdata-2020-11-23-data-intensive-app-5/">设计数据密集型应用 —— 分区</a>
          </li>
        
          <li>
            <a href="/2020/10/27/bigdata-2020-10-27-data-intensive-app-4/">设计数据密集型应用 —— 副本</a>
          </li>
        
          <li>
            <a href="/2020/09/20/bigdata-2020-09-20-data-intensive-app-3/">设计数据密集型应用3 —— 数据存储与读取</a>
          </li>
        
          <li>
            <a href="/2020/09/13/bigdata-2020-09-13-data-intensive-app-2/">设计数据密集型应用2 —— 数据模型与查询语言</a>
          </li>
        
          <li>
            <a href="/2020/09/06/bigdata-2020-09-06-data-intensive-app-1/">设计数据密集型应用1 —— 序</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Yang, Yue<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>




  </div>
</body>
</html>